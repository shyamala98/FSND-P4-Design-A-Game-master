Design of the Models for implementing Hangman:

Game:
The Game state for hangman include the following:
- target_word: This is the word that the player need to guess. Currently this word is picked from a list,
  this should be replaced by a real dictionary.
- partial_word_guessed: At the start of the game, this is set to a string of .'s. The length of the string is the
  same as the target word. With each correct guess, the '.' is replaced by the correct letter.
  The game is over and the player wins when there are no '.' in the partial_word_guessed
- attempts_allowed: This is the maximum number of attempts allowed. This field was provided so the client can set the
  maximum number of attempts. This should probably be a static field (not sure how that would be implemented) so all games
  generated by a client have the same number of attempts.
- attempts_remaining: This is the number of attempts remaining.
- letters_guessed: This is a cumulative string of letters guessed by the player
- guess_results: This is a string of 0 and 1's. For each guess, a 1 is appended to guess_results if the letter was present in
  the target word, otherwise a 0 is appended to guess_results.
  The letters_guessed and guess_results provide the game history information

RankingForm:
I decided to include a performance_index (%age of wins) and avg_score (average number of attempts remaining) instead of
providing just a single value. I did this to allow the client some flexibility in computing the ranking. Hmmm.. the
number of games played may also have factor in there ...

GameHistoryForm:
This contains the urlsafe_key, letter_guessed and is_present (a boolean value indicating whether the guess was right).
The GameHistoryForms is a container for all the moves in the game (multiple GameHistoryForm instances)
I could have probably returned the letters_guessed and guess_results strings to the client and leave the parsing to the client.

Some of the struggles ...
I could not decide on whether the API should set the maximum number of guesses allowed, or allow the client to set that value.
I also did not set up or use the ancestor relationship for the user-game models, since I did not quite understand how
this would extend to a 2 player game.